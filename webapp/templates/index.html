<!DOCTYPE html>
<html>
    <head>
     <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css"
       integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ=="
       crossorigin=""/>
     <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js"
       integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ=="
       crossorigin=""></script>

        <style>
            #map {
                height: 800px;
            }
        </style>
    </head>

    <body>
     <div id="map"></div>

        <script>
            var map = L.map('map');
            var viewTimeout;

            // Set view add tileLayer
            map.setView([50.0773301, 14.4269236], 8);
            L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: 'Â© OpenStreetMap'
            }).addTo(map);

            const clearMarkers = () => {
                map.eachLayer((layer) => {
                    if (layer.options.alt == "Marker")
                        layer.remove();
                });
            }

            const euclideanDistance = (lat1, lon1, lat2, lon2) => {
                return Math.sqrt( (lat1 - lat2)*(lat1-lat2) +
                    (lon1-lon2)*(lon1-lon2) )
            };

            const clusterPoints = (lats, lons, n) => {
                let clustersLats = [];
                let clustersLons = [];

                let unclusteredLats = lats
                let unclusteredLons = lons;

                while (unclusteredLats.length > 0) {

                    let clat = unclusteredLats.pop();
                    let clon = unclusteredLons.pop();

                    // If was last then lone cluster
                    if (unclusteredLats.length < 2) {
                        clustersLats.push([clat]);
                        clustersLons.push([clon]);
                        break;
                    }

                    let distances = [];
                    for (let i = 0; i < unclusteredLats.length; i++) {
                        let lat = unclusteredLats[i];
                        let lon = unclusteredLons[i];
                        distances.push( euclideanDistance(clat, clon, lat, lon) );
                    }

                    let clusterLats = [];
                    let clusterLons = [];
                    for (let i = 0; i < n; i++) {
                        if (distances.length < 1)
                            break;

                        let min = Infinity;
                        let minj = null;
                        for (let j = 0; j < distances.length; j++) {
                            let dist = distances[j];
                            if (dist < min) {
                                min = dist;
                                minj = j;
                            }
                        }

                        distances.splice(minj, 1);
                        let lat = unclusteredLats.splice(minj, 1);
                        let lon = unclusteredLons.splice(minj, 1);

                        clusterLats.push(lat);
                        clusterLons.push(lon);
                    }

                    let sumLats = 0;
                    let sumLons = 0;
                    for (let i = 0; i < clusterLats.length; i++) {
                        let lat = clusterLats[i];
                        let lon = clusterLons[i];

                        sumLats += parseFloat(lat);
                        sumLons += parseFloat(lon);
                    }

                    let centroidLat = sumLats / clusterLats.length;
                    let centroidLon = sumLons / clusterLats.length;

                    clustersLats.push(centroidLat);
                    clustersLons.push(centroidLon);
                }
                return [clustersLats, clustersLons];
            };

            const callAPI = async (url) => {
                const response = await fetch(url);
                const data = await response.json(); 

                return data;
            };

            // TODO: init map with centroids for clusters
            const fillMap = () => {
                /*
                const infoResponse = await fetch('/api/info/all');
                const infoJsonResp = await infoResponse.json(); 

                const geoResponse = await fetch('/api/geo/all');
                const geoJsonResp = await geoResponse.json(); 
                */

                const infoJsonResp = callAPI("/api/info/all");
                const geoJsonResp = callAPI("/api/geo/all");

                infoJsonResp.then( (objInfo) => {
                    console.log("INFO JSON RESP");
                    geoJsonResp.then( (objGeo) => {
                        console.log("GEO JSON RESPO");

                        let lats = [];
                        let lons = [];
                        Object.keys(objInfo).forEach( (key) => {
                            // Subjekt
                            let info = objInfo[key];

                            info["zarizeni"].forEach( (zarizeni) => {
                                zarizeni["mista"].forEach( (misto) => {
                                    let id_mista = misto["id_mista"];
                                    let geo = objGeo[id_mista];
                                    if (geo !== undefined) {
                                        let lat = geo.lat;
                                        let lon = geo.lon;

                                        lats.push(lat);
                                        lons.push(lon);
                                    }
                                });
                            });
                        });
                        console.log(lats.length);
                        let [clats, clons] = clusterPoints(lats, lons, 30);
                        console.log(clats.length);

                        for (let i = 0; i < clats.length; i++) {
                            let lat = clats[i];
                            let lon = clons[i];
                            L.marker([lat, lon]).addTo(map);
                        }

                });
            });
                
                /*
                Object.keys(obj_info).forEach( (key) => {
                    // Subjekt
                    let info = obj_info[key];
                    let subjekt_mista = {};

                    info["zarizeni"].forEach( (zarizeni) => {
                        zarizeni["mista"].forEach( (misto) => {
                            let id_mista = misto["id_mista"];
                            let geo = obj_geo[id_mista];
                            if (geo !== undefined) {
                                let lat = geo.lat;
                                let lon = geo.lon;
                                if ([lat, lon] in subjekt_mista) {
                                    subjekt_mista[[lat, lon]].push(`
                                    ${info.nazev} (${info.ico})<br>
                                    ${zarizeni.nazev} (${zarizeni.izo})<br>
                                    ${misto.adr1}, ${misto.adr2}, ${misto.adr3} (${id_mista})
                                    `);
                                } else {
                                    subjekt_mista[[lat, lon]] = [`
                                    ${info.nazev} (${info.ico})<br>
                                    ${zarizeni.nazev} (${zarizeni.izo})<br>
                                    ${misto.druh} | ${misto.adr1}, ${misto.adr2}, ${misto.adr3} (${id_mista})
                                    `];
                                }
                            }
                        });
                    });

                    Object.keys(subjekt_mista).forEach( (lat_lon) => {
                        let [lat, lon] = lat_lon.split(",");
                        let info = subjekt_mista[lat_lon];
                        L.marker([lat, lon]).addTo(map).bindPopup(info.join("<hr>"));
                    });
                });
                */
            }

            const fillView = async () => {


            }

            // Events
            map.on('moveend', () => { 
                clearTimeout(viewTimeout);
                viewTimeout = setTimeout(() => {
                     console.log(map.getBounds());
                    //clearMarkers();
                }, 1000);
            });

            // INIT
            fillMap();
        </script>
    </body>

</html>
